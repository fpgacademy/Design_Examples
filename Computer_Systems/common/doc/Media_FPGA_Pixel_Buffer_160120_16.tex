\subsubsection{Pixel Buffer}
\label{sec:pixel_buffer}

The pixel buffer for the video-out port holds the data (color) for each pixel that
will be displayed.  As illustrated in Figure \ref{fig:video_coord}, the
pixel buffer provides an image resolution of 
160 $\times$ 120 pixels, with the coordinate 0,0 being at the top-left corner of the image. 
Since the video-out port supports the screen resolution of 640 $\times$ 480, each of the
pixel values in
the pixel buffer is replicated 3 times in both the {\it x} and {\it y} dimensions when it is being
displayed on the screen.

\begin{figure}[h!]
   \begin{center}
       \includegraphics{../../../common/figs/Media_FPGA_Video_Coord_160120.pdf}
   \end{center}
   \caption{Pixel buffer coordinates.}
	\label{fig:video_coord}
\end{figure}

Figure \ref{fig:pixels}$a$ shows that each pixel color is represented as a 16-bit halfword, 
with five bits for the blue and red 
components, and six bits for green.  As depicted in part $b$ of Figure \ref{fig:pixels}, 
pixels are addressed in the pixel buffer by 
using the combination of a {\it base} address and an {\it x,y} offset.  In the \systemName~the default
address of the pixel buffer is {\sf 0x\baseAddressOffset 8000000}, which corresponds
to the starting address of the FPGA on-chip memory.  Using this scheme, the pixel at 
location 0,0 has the address {\sf 0x\baseAddressOffset 8000000}, 
the pixel 1,0 has the address {\it base} $+$ (00000000~00000001~0)$_2$ = {\sf 0x\baseAddressOffset 8000002}, 
the pixel 0,1 has the address {\it base} $+$ (00000001~00000000~0)$_2$ = {\sf 0x\baseAddressOffset 8000200},
and the pixel at location 159,119 has the address {\it base} $+$ (1110111 10011111 0)$_2$ = 
{\sf 0x\baseAddressOffset 800EF3E}. 

\begin{figure}[h!]
   \begin{center}
       \includegraphics{../../../common/figs/Media_FPGA_Video_Pixel_Values_16.pdf}
			 \caption*{Pixel values}
			 \vspace{1cm}
			 \includegraphics{../../../common/figs/Media_FPGA_Video_Pixel_Address_16_1.pdf}
			 \caption*{Pixel addresses}
   \end{center}
   \caption{Pixel values and addresses.}
	\label{fig:pixels}
\end{figure}

You can create an image by writing color values into the pixel addresses as described
above. A dedicated {\it pixel buffer controller} continuously reads this pixel 
data from sequential addresses in the corresponding
memory for display on the screen.  You can modify the pixel data at any time, simply
by writing to the pixel addresses. Thus, an image can be changed even when it is in the
process of being displayed.  However, it is also possible to avoid making changes to 
the pixel buffer while it is being displayed, by using the concept of {\it
double-buffering}.  In this scheme, two pixel buffers are involved, called the {\it front} 
and {\it back} buffers, described below.

\subsubsection{RGB Resampling}
The \systemName~contains an RGB Resampler for converting video streams between RGB color
formats. Reading from the 32-bit \textit{Status} register at address {\sf 0xFF203010}
provides information about alpha/no alpha, color/grayscale, and mode for the incoming and
outgoing formats. The incoming format for the \systemName~ video stream is {\sf 0x14},
which corresponds to no alpha, color, 16-bit RGB (5-bit Red, 6-bit Green, 5-bit Blue). 
More information can be found in the documentation called 
{\it Video IP Cores for Altera DE-Series Computer Systems}, available as part of the
\texttt{Hardware Components} tutorials on the 
{\small \href{https://www.fpgacademy.org/tutorials.html} {FPGAcademy.org}} website.

